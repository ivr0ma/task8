# task8 - задание на «Абстрактный тип данных»

Абстрактный тип данных (АТД) – это тип данных, который предоставляет для работы с элементами этого  
типа определённый набор функций или операций. Вся внутренняя структура такого типа спрятана от  
использующего его разработчика программного обеспечения, то есть мы абстрагируемся от его внутреннего  
устройства при использовании. В C++ АТД реализуется классом, в котором нет открытых членов-данных.  

Цель – реализовать и протестировать новый класс, представляющий абстрактный тип данных, т.е. такой,  
пользователи которого могут обращаться только к публичным операциям, предусмотренными создателем класса,  
и не имеют информации о внутреннем его устройстве.  

Средство – язык С++  

Пользователем (клиентом) класса считается не "пользователь программы" или "компьютерный пользователь"  
вообще, а программист, использующий ваш класс для решения своих задач, пишущий свою программу на его основе.  
Иногда также под пользователями класса понимаются другие классы, фрагменты программ, которые пользуются  
его услугами.  

#### Дополнительные требования и условия к Task2
По заданию требуется использовать язык C++ (а не C), старайтесь использовать средства языка С++ (ввод-вывод  
cin/cout и т.п.; new и delete, а не malloc/free).  
В данном задании не разрешается использовать контейнеры из STL языка C++. Написание собственных аналогов  
стандартных STL контейнеров (например, string и vector) с соответствующим набором функций приветствуется.  
Методы (нестатические), которые не изменяют состояние объекта, должны быть объявлены как константные, если  
это не противоречит смыслу использования АТД.  

Программа должна быть представлена минимум тремя файлами:  
- <АТД>.h – объявлено все, что необходимо включить в программу, для использования вашего класса АТД,
- <АТД>.cpp – реализации нетривиальных методов класса,
- main.cpp – пользовательский интерфейс для тестирования.

Для класса, реализующего АТД, необходимо определить:
- конструктор по умолчанию,
- конструктор копирования (глубокое копирование, если необходимо),
- операцию присваивания (предварительно уничтожить старое значение + см. требование выше относительно
копирования),
- деструктор (стоит предусмотреть ситуацию повторного вызова деструктора: он не должен пытаться в этом
случае освобождать в динамической памяти объекты повторно – это может привести к ошибке выполнения),
- базовый класс исключения, выбрасываемого всеми операциями класса, возможно с потомками – для более
детальной классификации ошибок, – вложен в основной класс (например, string_list::error).
Правильный вывод ошибок должен содержать, хотя бы приблизительно, номер строки, в которой произошла
ошибка.
