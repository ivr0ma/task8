# task8 - задание на «Абстрактный тип данных»

Абстрактный тип данных (АТД) – это тип данных, который предоставляет для работы с элементами этого  
типа определённый набор функций или операций. Вся внутренняя структура такого типа спрятана от  
использующего его разработчика программного обеспечения, то есть мы абстрагируемся от его внутреннего  
устройства при использовании. В C++ АТД реализуется классом, в котором нет открытых членов-данных.  

Цель – реализовать и протестировать новый класс, представляющий абстрактный тип данных, т.е. такой,  
пользователи которого могут обращаться только к публичным операциям, предусмотренными создателем класса,  
и не имеют информации о внутреннем его устройстве.  

Средство – язык С++  

Пользователем (клиентом) класса считается не "пользователь программы" или "компьютерный пользователь"  
вообще, а программист, использующий ваш класс для решения своих задач, пишущий свою программу на его основе.  
Иногда также под пользователями класса понимаются другие классы, фрагменты программ, которые пользуются  
его услугами.  

#### Дополнительные требования и условия к Task2
По заданию требуется использовать язык C++ (а не C), старайтесь использовать средства языка С++ (ввод-вывод  
cin/cout и т.п.; new и delete, а не malloc/free).  
В данном задании не разрешается использовать контейнеры из STL языка C++. Написание собственных аналогов  
стандартных STL контейнеров (например, string и vector) с соответствующим набором функций приветствуется.  
Методы (нестатические), которые не изменяют состояние объекта, должны быть объявлены как константные, если  
это не противоречит смыслу использования АТД.  

Программа должна быть представлена минимум тремя файлами:  
- <АТД>.h – объявлено все, что необходимо включить в программу, для использования вашего класса АТД,
- <АТД>.cpp – реализации нетривиальных методов класса,
- main.cpp – пользовательский интерфейс для тестирования.

Для класса, реализующего АТД, необходимо определить:
- конструктор по умолчанию,
- конструктор копирования (глубокое копирование, если необходимо),
- операцию присваивания (предварительно уничтожить старое значение + см. требование выше относительно
копирования),
- деструктор (стоит предусмотреть ситуацию повторного вызова деструктора: он не должен пытаться в этом
случае освобождать в динамической памяти объекты повторно – это может привести к ошибке выполнения),
- базовый класс исключения, выбрасываемого всеми операциями класса, возможно с потомками – для более
детальной классификации ошибок, – вложен в основной класс (например, string_list::error).
Правильный вывод ошибок должен содержать, хотя бы приблизительно, номер строки, в которой произошла
ошибка.

## Вариант: Вещественная матрица
Вещественным числом считается число типа double. Необходимо реализовать вещественную матрицу –  
понятие линейной алгебры. Нужно обеспечить пользователя класса естественным интерфейсом  
математических операций для работы с матрицами и составления вычислительных программ.  
Для удобства тестирования и отладки ввести строковое представление матрицы, похожее на инициализатор  
двумерного массива. Так, строка "{{1, 0, 0}, {0, 1, 0.5}}" обозначает матрицу размера 2x3:  
| 1  0  0   |  
| 0  1  0.5 |  

Обязательные операции:  
1) matrix( int n, int m ) – конструктор матрицы размера n´m со значениями 0.0;  
2) matrix( double ) – матрица 1´1 с этим элементом;  
3) matrix( double*, int m ) – матрица-строка из массива длины m;  
4) matrix( int n, double* ) – матрица-столбец из массива длины n;  
5) matrix( char*) – из строкового представления (см. выше);  
6) static matrix matrix::identity( int n ) – возвращает единичную матрицу размера n;  
7) static matrix matrix::diagonal( double* vals, int n ) – возвращает диагональную матрицу размера n с заданными  
элементами по главной диагонали;  
8) int matrix::rows() – число строк;  
9) int matrix::columns() – число столбцов;  
10) matrix::set( int i, int j, double val ) – присвоить значение элементу [i][j];  
11) matrix matrix::matrix[ i ] – i-я строка в виде новой матрицы, если такая строка есть – 1-й приоритет  
12) matrix matrix::matrix[ j ] – j-й столбец в виде новой матрицы, если такой столбец есть – 2-й приоритет, –  
иначе ошибка (если M – матрица, то M[i] – матрица из одной строки, а М[i][j] – матрица 1´1 из одного элемента);  
13) matrix * scalar и matrix*=scalar – умножение матрицы на скаляр;  
14) перегрузка операции << – вывод матрицы, в привычном двумерном виде.  

## Расширение варианта  
Все арифметические операции выбрасывают исключение, если матрицы несовместимы по размерам.  

Дополнительные функции:  
15) matrix + matrix ;  
16) matrix += matrix ;  
17) matrix - matrix ;  
18) matrix -= matrix ;  
19) matrix * matrix ;  
20) matrix *= matrix ;  
21) -matrix – унарный минус, применить ко всем элементам ;  
22) matrix == matrix – точность сравнения задана статической константой matrix::EPS ;  
23) matrix != matrix ;  
24) matrix | matrix – конкатенировать (приписать) матрицы вертикально (вторую справа от первой);  
25) matrix / matrix – конкатенировать (приписать) матрицы горизонтально (вторую под первой).  
